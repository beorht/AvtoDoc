###  Тема урока
#### Тема № 14: Системы обеспечения целостности данных: CRC, хеш-функции (Keyed/Keyless), MD5, SHA1 и атаки полным подбором

Основные разделы образовательного материала:
1.  Введение в концепцию целостности данных и ее механизмы.
2.  CRC (Cyclic Redundancy Check): Обнаружение ошибок и его ограничения.
3.  Хеш-функции: Общие принципы, Keyless и Keyed хеши.
4.  MD5 и SHA1: Свойства, применение, уязвимости и современные рекомендации.
5.  Определение хеш-значений и взлом ключей методом полного подбора (брутфорс).

Текст образовательного материала:

### 1. Введение в концепцию целостности данных и ее механизмы

**Целостность данных** — это свойство данных, означающее, что они не были изменены или повреждены несанкционированным образом в процессе хранения или передачи. Это одна из трех основных составляющих информационной безопасности, наряду с конфиденциальностью (защита от несанкционированного доступа) и доступностью (обеспечение доступа к данным по запросу).

**Почему целостность данных важна?** Представьте, что во время банковской транзакции сумма перевода была случайно или злонамеренно изменена, или системный файл операционной системы был поврежден. Последствия могут быть катастрофическими. Механизмы обеспечения целостности данных помогают обнаружить такие изменения, а в некоторых случаях и предотвратить их.

В рамках данной лекции мы рассмотрим два основных подхода к проверке целостности:
*   **CRC** (Cyclic Redundancy Check) – для обнаружения *случайных* ошибок.
*   **Хеш-функции** (Hash Functions) – для обнаружения *как случайных, так и злонамеренных* изменений.

### 2. CRC (Cyclic Redundancy Check): Обнаружение ошибок и его ограничения

**CRC (Циклический Избыточный Код)** — это математический алгоритм, используемый для обнаружения ошибок в данных, передаваемых по каналам связи или хранящихся на носителях. Он широко применяется в сетевых протоколах (например, Ethernet, Wi-Fi), файловых системах и архиваторах.

**Как работает CRC:**
Алгоритм CRC основан на делении исходного блока данных на заранее выбранный многочлен (полином). Остаток от этого деления и является контрольной суммой CRC. Эта контрольная сумма добавляется к исходным данным. При получении данных получатель производит то же деление. Если вычисленная им контрольная сумма совпадает с полученной, данные считаются неповрежденными.

**Пример:**
Если у вас есть блок данных `D` и выбран полином `P`, вычисляется `CRC(D)`. Передаются данные `D + CRC(D)`. Получатель вычисляет `CRC(D')` от принятых данных `D'` и сравнивает с `CRC(D)`.

**Свойства CRC:**
*   **Эффективность в обнаружении случайных ошибок:** CRC очень хорошо обнаруживает распространенные типы ошибок, такие как одиночные битовые ошибки, пакетные ошибки (несколько следующих друг за другом битов) и большинство ошибок с четным числом битов.
*   **Фиксированный размер:** Длина CRC-кода фиксирована (например, CRC-32 выдает 32-битное значение).
*   **Не является криптографической функцией:** CRC не предназначен для защиты от злонамеренных изменений. Злоумышленник может легко изменить данные таким образом, чтобы новая контрольная сумма CRC совпала с оригинальной, подделав данные и пересчитав CRC.

**Вывод:** CRC является отличным инструментом для проверки целостности данных в условиях *случайного* возникновения ошибок, но абсолютно не пригоден для обеспечения криптографической целостности и аутентификации.

### 3. Хеш-функции: Общие принципы, Keyless и Keyed хеши

**Хеш-функция** (или функция свёртки, хеш-алгоритм) — это математическая функция, которая преобразует входные данные произвольного размера (сообщение, файл, строка) в выходную строку фиксированного размера, называемую **хеш-значением**, **хешем**, **дайджестом** или **отпечатком**.

**Ключевые свойства криптографических хеш-функций:**
1.  **Детерминированность:** Один и тот же вход всегда порождает один и тот же хеш.
2.  **Быстрота вычисления:** Вычисление хеша для любого сообщения должно быть быстрым.
3.  **Односторонность (необратимость):** Практически невозможно восстановить исходное сообщение по его хешу.
4.  **Лавинный эффект:** Небольшое изменение во входных данных (даже один бит) должно приводить к значительному изменению хеша.
5.  **Устойчивость к коллизиям:**
    *   **Слабая устойчивость к коллизиям (устойчивость к первому прообразу):** Должно быть вычислительно невозможным найти другое сообщение, которое имеет тот же хеш, что и заданное.
    *   **Сильная устойчивость к коллизиям (устойчивость ко второму прообразу):** Должно быть вычислительно невозможным найти два *различных* сообщения, которые имеют одинаковый хеш. Это самое важное свойство для обеспечения целостности.

**Типы хеш-функций для обеспечения целостности:**

#### 3.1. Keyless Хеш-функции (бесключевые)
Это обычные криптографические хеш-функции, которые не используют секретный ключ. Любой желающий может вычислить хеш для любого сообщения.
*   **Примеры:** MD5, SHA1, SHA-256, SHA-3.
*   **Применение:**
    *   Проверка целостности загруженных файлов (сравнение хеша, предоставленного издателем).
    *   Хранение паролей (хранят хеши паролей, а не сами пароли).
    *   Цифровые подписи (подписывается хеш документа, а не сам документ).
*   **Ограничения:** Если злоумышленник может изменить как данные, так и их хеш, или если функция имеет известные коллизии, целостность данных не может быть гарантирована.

#### 3.2. Keyed Хеш-функции (ключевые)
Это хеш-функции, которые используют секретный ключ для вычисления хеш-значения. Наиболее распространенным примером является **HMAC (Hash-based Message Authentication Code)**.
*   **Пример:** HMAC-SHA256, HMAC-MD5 (хотя MD5 сам по себе сломан, его использование в HMAC может быть приемлемым в некоторых *старых* системах, но не рекомендуется).
*   **Как работает HMAC:** HMAC вычисляется с использованием секретного ключа, известного только отправителю и получателю. Формула выглядит примерно так: `HMAC(K, M) = H(K XOR opad || H(K XOR ipad || M))`, где `K` — ключ, `M` — сообщение, `H` — базовая хеш-функция (например, SHA256), `opad` и `ipad` — фиксированные константы.
*   **Применение:**
    *   **Аутентификация сообщений:** Подтверждает, что сообщение пришло от ожидаемого отправителя (владельца ключа) и не было изменено в пути.
    *   **Защита сессий:** Токены сессий, защищенные HMAC, гарантируют их неизменность.
    *   **API-аутентификация:** Многие API используют HMAC для проверки подлинности запросов.
*   **Преимущества:** HMAC обеспечивает как целостность данных, так и их аутентификацию, поскольку только владелец секретного ключа может сгенерировать корректный HMAC для данного сообщения.

**Вывод:** Хеш-функции являются краеугольным камнем обеспечения целостности в криптографии. Keyless хеши используются для проверки неизменности данных, если источник хеша доверен. Keyed хеши (HMAC) обеспечивают как целостность, так и аутентификацию, защищая данные от модификации и подделки.

### 4. MD5 и SHA1: Свойства, применение, уязвимости и современные рекомендации

**MD5 (Message-Digest Algorithm 5)** и **SHA1 (Secure Hash Algorithm 1)** — это две исторически широко используемые криптографические хеш-функции.

#### 4.1. MD5
*   **Размер хеша:** 128 бит (32 шестнадцатеричных символа).
*   **История:** Разработан Рональдом Ривестом в 1991 году. Быстро стал стандартом де-факто для проверки целостности файлов и хранения паролей.
*   **Уязвимости:**
    *   В 2004 году были обнаружены первые практические методы поиска коллизий.
    *   В 2008 году была продемонстрирована атака, позволяющая создать два разных файла с одинаковым хешем MD5, что ставит под угрозу его использование в цифровых подписях и сертификатах.
    *   Коллизии для MD5 теперь могут быть найдены за считанные секунды на обычном компьютере.
*   **Современный статус:** **Криптографически сломан.**
*   **Рекомендации:** **НЕ использовать MD5 для любых задач, требующих криптографической безопасности** (проверка целостности от злонамеренных изменений, цифровые подписи, генерация случайных чисел). Может быть *условно* приемлем для проверки на случайные изменения, если источник хеша абсолютно доверен и нет риска злонамеренной подделки (например, для быстрой проверки скачанного ISO-образа, если сам сайт с хешем не скомпрометирован).

#### 4.2. SHA1
*   **Размер хеша:** 160 бит (40 шестнадцатеричных символов).
*   **История:** Разработан Агентством национальной безопасности США (NSA) и опубликован NIST в 1995 году как преемник SHA-0 и более безопасная альтернатива MD5.
*   **Уязвимости:**
    *   Теоретические атаки на SHA1 были известны давно, но практическая атака казалась слишком дорогой.
    *   В 2017 году Google успешно продемонстрировал первую практическую атаку по поиску коллизий для SHA1 (`SHAttered` атака), создав два разных PDF-файла с одинаковым хешем SHA1. Стоимость атаки была значительной, но вполне посильной для крупных организаций.
*   **Современный статус:** **Криптографически сломан.**
*   **Рекомендации:** **НЕ использовать SHA1 для любых новых задач, требующих криптографической безопасности.** Существует активный процесс миграции от SHA1 во многих областях, включая сертификаты SSL/TLS и системы контроля версий (например, Git, хотя и использует SHA1, его модель безопасности снижает риск).

**Современные альтернативы:**
Вместо MD5 и SHA1 следует использовать более стойкие хеш-функции:
*   **SHA-2:** Семейство алгоритмов (SHA-256, SHA-512), которые до сих пор считаются безопасными для большинства применений.
*   **SHA-3:** Новый стандарт, разработанный в рамках конкурса NIST, предлагающий совершенно другую внутреннюю структуру, что делает его устойчивым к тем же атакам, которые сломали MD5 и SHA1.

**Вывод:** MD5 и SHA1 показали свою уязвимость к коллизионным атакам. Их использование в новых проектах для обеспечения криптографической безопасности недопустимо. Переход на SHA-2 или SHA-3 является обязательным требованием для современных систем.

### 5. Определение хеш-значений и взлом ключей методом полного подбора (брутфорс)

Метод полного подбора, или **брутфорс (brute-force attack)**, заключается в систематическом переборе всех возможных комбинаций для нахождения искомого значения. В контексте хеш-функций и криптографии он может применяться в нескольких сценариях.

#### 5.1. Поиск исходных данных по известному хешу (атака на прообраз)
Основное свойство криптографических хеш-функций — односторонность, т.е. невозможность восстановить исходные данные по их хешу. Брутфорс-атака на прообраз заключается в попытке сгенерировать случайные или последовательные входные данные, хешировать их и сравнивать с целевым хешем до тех пор, пока не будет найдено совпадение.

*   **Применимость:** Для хорошо спроектированных криптографических хеш-функций (например, SHA-256) пространство возможных входных данных настолько велико, что такой перебор занимает астрономически много времени и является практически невозможным.
*   **Исключения:**
    *   **Короткие или слабые пароли:** Если хешируются пароли пользователей, которые используют простые слова или короткие комбинации, злоумышленник может использовать словари или брутфорс-перебор по ограниченному набору символов.
        *   **Rainbow Tables (радужные таблицы):** Это предварительно вычисленные таблицы, содержащие пары "хеш-пароль" для большого количества распространенных паролей. Они позволяют значительно ускорить процесс поиска пароля по его хешу, не требуя перебора на лету.
    *   **Недостаточная "соль" (salt) или ее отсутствие:** При хешировании паролей важно использовать случайную уникальную "соль" для каждого пароля. Соль добавляется к паролю перед хешированием (`хеш = H(пароль + соль)`). Это делает радужные таблицы неэффективными, так как для каждой соли требуется своя отдельная таблица.
*   **Вывод:** Чтобы защититься от брутфорса паролей, используйте длинные, сложные пароли, случайные соли и медленные хеш-функции, специально разработанные для хеширования паролей (например, Argon2, scrypt, bcrypt).

#### 5.2. Поиск коллизий
Это поиск двух разных входных данных `M1` и `M2` таких, что `H(M1) = H(M2)`.
*   **Атака "дней рождения" (Birthday Attack):** Из-за математического феномена, известного как "парадокс дня рождения", найти *любую* пару коллизий гораздо проще, чем найти вход для *конкретного* хеша. Для хеша длиной `N` бит, ожидаемое количество попыток для нахождения коллизии составляет примерно `2^(N/2)`.
    *   Пример: Для MD5 (128 бит) это `2^(128/2) = 2^64` попыток, что уже возможно для современного оборудования. Для SHA1 (160 бит) это `2^(160/2) = 2^80`, что значительно сложнее, но, как показал Google, уже достижимо.
*   **Последствия:** Коллизии позволяют злоумышленнику создать "злонамеренный" документ, который имеет тот же хеш, что и "доброкачественный", подрывая доверие к целостности данных и цифровым подписям.

#### 5.3. Взлом ключей Keyed хеш-функций (HMAC)
При использовании HMAC для аутентификации сообщений, секретный ключ `K` должен быть известен только отправителю и получателю. Злоумышленник, перехватив сообщение `M` и его HMAC `T`, может попытаться найти ключ `K` методом полного подбора.

*   **Как это работает:** Злоумышленник перебирает возможные ключи `K'`, вычисляет `HMAC(K', M)` и сравнивает результат с перехваченным `T`. Если они совпадают, ключ `K'` найден.
*   **Защита:** Единственная эффективная защита — использование достаточно длинного и случайного ключа. Длина ключа для HMAC должна соответствовать уровню безопасности, который предоставляет базовая хеш-функция. Например, для HMAC-SHA256 рекомендуется ключ длиной не менее 256 бит. Если ключ короткий или предсказуемый, брутфорс может быть успешным.

**Вывод по брутфорсу:**
Брутфорс-атаки подчеркивают важность использования криптографически стойких хеш-функций, достаточной длины ключей и паролей, а также применение специализированных механизмов, таких как "соль" и медленные хеш-функции, для защиты от перебора. Уязвимости MD5 и SHA1 к коллизиям делают их небезопасными, так как брутфорс коллизий стал реальным.

 

**Общий вывод по лекции:**
Обеспечение целостности данных является критически важным аспектом информационной безопасности. CRC эффективен для обнаружения случайных ошибок, но не обеспечивает защиту от злонамеренных действий. Криптографические хеш-функции, такие как Keyless хеши (MD5, SHA1, SHA-2, SHA-3) и Keyed хеши (HMAC), предоставляют более сильные гарантии целостности. Однако важно использовать современные и криптографически стойкие алгоритмы. MD5 и SHA1 **больше не являются безопасными** для целей, где требуется криптографическая стойкость, из-за известных коллизионных атак и уязвимостей к брутфорсу. Современные системы должны применять SHA-2, SHA-3 или другие рекомендованные алгоритмы, а также использовать надежные ключи и пароли для предотвращения атак методом полного подбора.